# Task ID: 5
# Title: Create Custom Hooks for Repeated Logic
# Status: pending
# Dependencies: 1, 4
# Priority: medium
# Description: Extract repeated logic from components into custom hooks to improve code reusability and maintainability.
# Details:
Identify common patterns across components such as:
1. Form handling logic
2. Authentication state checks
3. Data fetching patterns
4. Animation controls

Create custom hooks for each pattern, for example:
```tsx
// Authentication hook
export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (event, session) => {
        setUser(session?.user ?? null);
        setIsLoading(false);
      }
    );
    
    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);
  
  return { user, isLoading };
}
```

Place hooks in a dedicated `hooks` directory and document their usage.

# Test Strategy:
Write unit tests for each custom hook using React Testing Library's renderHook utility. Test different scenarios including loading states, error states, and successful operations. Document usage examples for each hook.

# Subtasks:
## 1. Create Form Handling Custom Hook [completed]
### Dependencies: None
### Description: Extract form handling logic into a reusable custom hook to manage form state, validation, and submission across components.
### Details:
Implementation steps:
1. Create a `hooks` directory in the project structure if it doesn't exist
2. Create a file named `useForm.ts` in the hooks directory
3. Implement the `useForm` hook with the following features:
   - Form state management (inputs, errors, touched fields)
   - Validation functionality
   - Form submission handling
   - Reset form capability
4. Add JSDoc comments to document parameters, return values, and usage examples
5. Create basic tests to verify the hook works correctly

Example implementation:
```tsx
export function useForm<T extends Record<string, any>>(
  initialValues: T,
  validate?: (values: T) => Partial<Record<keyof T, string>>,
  onSubmit?: (values: T) => void | Promise<void>
) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setValues({ ...values, [name]: value });
  };

  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    const { name } = e.target;
    setTouched({ ...touched, [name]: true });
    if (validate) {
      setErrors(validate(values));
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setTouched(Object.keys(values).reduce((acc, key) => ({ ...acc, [key]: true }), {}));
    
    if (validate) {
      const validationErrors = validate(values);
      setErrors(validationErrors);
      
      if (Object.keys(validationErrors).length === 0 && onSubmit) {
        setIsSubmitting(true);
        try {
          await onSubmit(values);
        } finally {
          setIsSubmitting(false);
        }
      }
    } else if (onSubmit) {
      setIsSubmitting(true);
      try {
        await onSubmit(values);
      } finally {
        setIsSubmitting(false);
      }
    }
  };

  const resetForm = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    setValues
  };
}
```

Testing approach:
- Write unit tests using Jest/React Testing Library
- Test form initialization, input changes, validation, and submission
- Verify error handling and form reset functionality works as expected

## 2. Implement Authentication and User State Custom Hook [pending]
### Dependencies: None
### Description: Create a custom hook that manages authentication state, user data, and related authentication operations across the application.
### Details:
Implementation steps:
1. Create a file named `useAuth.ts` in the hooks directory
2. Implement the authentication hook to handle:
   - User authentication state
   - Login/logout operations
   - Session persistence
   - Loading states during authentication processes
3. Ensure the hook properly cleans up subscriptions when unmounted
4. Add comprehensive documentation with JSDoc comments
5. Create tests to verify authentication state management

Example implementation:
```tsx
import { useState, useEffect } from 'react';
import { supabase } from '../lib/supabaseClient'; // Adjust import path as needed
import type { User, Session } from '@supabase/supabase-js'; // Add appropriate types

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Get initial session
    const getInitialSession = async () => {
      const { data } = await supabase.auth.getSession();
      setSession(data.session);
      setUser(data.session?.user ?? null);
      setIsLoading(false);
    };
    
    getInitialSession();

    // Set up auth listener
    const { data: authListener } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
        setIsLoading(false);
      }
    );
    
    // Cleanup subscription
    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  const login = async (email: string, password: string) => {
    setIsLoading(true);
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    setIsLoading(false);
    return { error };
  };

  const signUp = async (email: string, password: string) => {
    setIsLoading(true);
    const { error } = await supabase.auth.signUp({ email, password });
    setIsLoading(false);
    return { error };
  };

  const logout = async () => {
    setIsLoading(true);
    const { error } = await supabase.auth.signOut();
    setIsLoading(false);
    return { error };
  };

  return {
    user,
    session,
    isLoading,
    login,
    signUp,
    logout,
    isAuthenticated: !!user
  };
}
```

Testing approach:
- Mock Supabase authentication service responses
- Test initial loading state, successful authentication, and logout
- Verify proper cleanup of listeners
- Test error handling during authentication operations

## 3. Develop Data Fetching Custom Hook [pending]
### Dependencies: None
### Description: Create a reusable data fetching hook that handles loading states, error handling, and caching for API requests throughout the application.
### Details:
Implementation steps:
1. Create a file named `useFetch.ts` in the hooks directory
2. Implement the data fetching hook with features for:
   - Handling async data fetching with loading states
   - Error handling and retry mechanisms
   - Optional caching of responses
   - Support for pagination where applicable
3. Add comprehensive JSDoc documentation
4. Create tests to verify all data fetching scenarios

Example implementation:
```tsx
import { useState, useEffect, useCallback } from 'react';

type FetchState<T> = {
  data: T | null;
  isLoading: boolean;
  error: Error | null;
};

type UseFetchOptions = {
  immediate?: boolean;
  cacheKey?: string;
  cacheDuration?: number; // in milliseconds
};

export function useFetch<T>(
  url: string,
  options: RequestInit = {},
  fetchOptions: UseFetchOptions = { immediate: true }
) {
  const [state, setState] = useState<FetchState<T>>({
    data: null,
    isLoading: fetchOptions.immediate ?? true,
    error: null,
  });

  const fetchData = useCallback(async () => {
    // Check cache if cacheKey is provided
    if (fetchOptions.cacheKey) {
      const cached = localStorage.getItem(fetchOptions.cacheKey);
      if (cached) {
        const { data, timestamp } = JSON.parse(cached);
        const isValid = fetchOptions.cacheDuration
          ? Date.now() - timestamp < fetchOptions.cacheDuration
          : true;
          
        if (isValid) {
          setState({ data, isLoading: false, error: null });
          return;
        }
      }
    }

    setState(prev => ({ ...prev, isLoading: true }));
    
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Cache the result if cacheKey is provided
      if (fetchOptions.cacheKey) {
        localStorage.setItem(
          fetchOptions.cacheKey,
          JSON.stringify({ data, timestamp: Date.now() })
        );
      }
      
      setState({ data, isLoading: false, error: null });
    } catch (error) {
      setState({ data: null, isLoading: false, error: error as Error });
    }
  }, [url, options, fetchOptions.cacheKey, fetchOptions.cacheDuration]);

  useEffect(() => {
    if (fetchOptions.immediate) {
      fetchData();
    }
  }, [fetchData, fetchOptions.immediate]);

  const refetch = useCallback(() => {
    fetchData();
  }, [fetchData]);

  return { ...state, refetch };
}
```

Extended functionality for pagination:
```tsx
export function usePaginatedFetch<T>(
  baseUrl: string,
  options: RequestInit = {},
  pageSize: number = 10
) {
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const url = `${baseUrl}?page=${page}&limit=${pageSize}`;
  
  const { data, isLoading, error, refetch } = useFetch<T[]>(url, options);
  
  useEffect(() => {
    if (data && data.length < pageSize) {
      setHasMore(false);
    } else {
      setHasMore(true);
    }
  }, [data, pageSize]);
  
  const nextPage = () => {
    if (hasMore && !isLoading) {
      setPage(prev => prev + 1);
    }
  };
  
  const prevPage = () => {
    if (page > 1 && !isLoading) {
      setPage(prev => prev - 1);
    }
  };
  
  return { 
    data, 
    isLoading, 
    error, 
    refetch, 
    page, 
    hasMore, 
    nextPage, 
    prevPage,
    resetPage: () => setPage(1)
  };
}
```

Testing approach:
- Mock fetch API using Jest
- Test successful data fetching, loading states, and error handling
- Verify caching mechanism works correctly
- Test pagination functionality where applicable
- Ensure refetch functionality works as expected

